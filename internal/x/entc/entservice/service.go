package entservice

import (
	"context"
	"fmt"

	"entgo.io/ent/entc/gen"
	"github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"
	"github.com/syralon/coconutc/internal/tools/text"
	"github.com/syralon/coconutc/pkg/annotation/entproto"
)

func ServiceBuilder(pkg, repoPkg string) BuildFunc {
	return func(ctx context.Context, node *gen.Type, opts *BuildOptions) (*jen.File, error) {
		file := jen.NewFile(pkg)
		file.HeaderComment("Code generated by coconutc. DO NOT EDIT.")
		file.HeaderComment("https://github.com/syralon/coconutc")
		file.ImportAlias(opts.ProtoPackage, "pb")
		b := &serviceBuilder{
			BuildOptions:      opts,
			name:              fmt.Sprintf("%sService", node.Name),
			node:              node,
			file:              file,
			repositoryPackage: repoPkg,
		}
		err := b.build(ctx)
		if err != nil {
			return nil, err
		}
		return file, nil
	}
}

type serviceBuilder struct {
	*BuildOptions
	repositoryPackage string

	file *jen.File
	name string
	node *gen.Type
}

func (b *serviceBuilder) build(_ context.Context) error {
	b.structs()
	for _, method := range b.APIOptions.Method.Methods() {
		switch method {
		case entproto.GET:
			b.get()
		case entproto.LIST:
			b.list()
		case entproto.CREATE:
			b.create()
		case entproto.UPDATE:
			b.update()
		case entproto.DELETE:
			b.delete()
		default:
		}
	}
	b.set()
	b.edges()
	return nil
}

func (b *serviceBuilder) structs() {
	defer b.file.Line()
	b.file.Type().Id(b.name).Struct(
		jen.Op("*").Qual(b.ProtoPackage, fmt.Sprintf("Unsafe%sServer", b.name)),
		jen.Id("rep").Qual(b.repositoryPackage, fmt.Sprintf("%sRepository", b.node.Name)),
	)
	b.file.Func().Id("New" + b.name).Params(
		jen.Id("rep").Qual(b.repositoryPackage, fmt.Sprintf("%sRepository", b.node.Name)),
	).Op("*").Id(b.name).
		Block(
			jen.Return(jen.Op("&").Id(b.name).Block(jen.Id("rep").Op(":").Id("rep").Op(","))),
		)
}

func (b *serviceBuilder) request(op, method string) *jen.Statement {
	name := messageName(method, b.node.Name) + "Request"
	return jen.Op(op).Qual(b.ProtoPackage, name)
}

func (b *serviceBuilder) response(op, method string) *jen.Statement {
	name := messageName(method, b.node.Name) + "Response"
	return jen.Op(op).Qual(b.ProtoPackage, name)
}

func (b *serviceBuilder) listResponse(node *gen.Type) []jen.Code {
	return []jen.Code{
		jen.Id("Data").Op(":").Qual(pkgXSlices, "Trans").Call(
			jen.Id("data"),
			jen.Qual(b.repositoryPackage, fmt.Sprintf("%sToProto", node.Name)),
		).Op(","),
		jen.Id("Paginator").Op(":").Id("paginator").Op(","),
	}
}

func (b *serviceBuilder) fn(method string, vars *jen.Statement, args []jen.Code, responses []jen.Code) {
	defer b.file.Line()
	b.file.Func().
		Params(jen.Id("s").Op("*").Id(b.name)).Id(method).
		Params(
			ctxVar(),
			jen.Id("request").Add(b.request("*", method)),
		).
		Params(
			b.response("*", method),
			jen.Error(),
		).
		Block(
			vars.Op(":=").Id("s.rep").Dot(text.EntPascal(strcase.ToSnake(method))).Call(args...),
			ifErr(),
			jen.Return(
				b.response("&", method).Block(responses...),
				jen.Nil(),
			),
		)
}

func (b *serviceBuilder) get() {
	b.fn(
		"Get",
		list("data", "err"),
		[]jen.Code{
			jen.Id("ctx"),
			protoID(b.node, jen.Id("request").Dot("GetId").Call()),
		},
		[]jen.Code{
			jen.Id("Data").Op(":").Qual(b.repositoryPackage, fmt.Sprintf("%sToProto", b.node.Name)).Call(jen.Id("data")).Op(","),
		},
	)
}

func (b *serviceBuilder) list() {
	b.fn(
		"List",
		list("data", "paginator", "err"),
		[]jen.Code{
			jen.Id("ctx"),
			jen.Id("request").Dot("GetOptions").Call(),
			jen.Id("request").Dot("GetPaginator").Call(),
		},
		b.listResponse(b.node),
	)
}

func (b *serviceBuilder) create() {
	b.fn(
		"Create",
		list("data", "err"),
		[]jen.Code{
			jen.Id("ctx"),
			jen.Id("request").Dot("GetCreate").Call(),
		},
		[]jen.Code{
			jen.Id("Data").Op(":").Qual(b.repositoryPackage, fmt.Sprintf("%sToProto", b.node.Name)).Call(jen.Id("data")).Op(","),
		},
	)
}

func (b *serviceBuilder) update() {
	b.fn(
		"Update",
		jen.Err(),
		[]jen.Code{
			jen.Id("ctx"),
			protoID(b.node, jen.Id("request").Dot("GetId").Call()),
			jen.Id("request").Dot("GetUpdate").Call(),
		},
		[]jen.Code{},
	)
}

func (b *serviceBuilder) delete() {
	b.fn(
		"Delete",
		jen.Err(),
		[]jen.Code{
			jen.Id("ctx"),
			protoID(b.node, jen.Id("request").Dot("GetId").Call()),
		},
		[]jen.Code{},
	)
}

func (b *serviceBuilder) set() {
	for _, v := range b.node.Fields {
		if v.Name == "created_at" || v.Name == "updated_at" {
			continue
		}
		if v.Immutable {
			continue
		}
		fieldOpts, err := entproto.GetFieldOptions(v.Annotations)
		if err != nil {
			panic(err)
		}
		if fieldOpts.Immutable || !fieldOpts.Settable {
			continue
		}
		fnName := fmt.Sprintf("Set%s", text.ProtoPascal(v.Name))

		b.fn(
			fnName,
			jen.Err(),
			[]jen.Code{
				jen.Id("ctx"),
				protoID(b.node, jen.Id("request").Dot("GetId").Call()),
				jen.Id("request").Dot("Get" + text.ProtoPascal(v.Name)).Call(),
			},
			[]jen.Code{},
		)
	}
}

func (b *serviceBuilder) edges() {
	for _, edge := range b.node.Edges {
		opts, err := entproto.GetAPIOptions(edge.Annotations)
		if err != nil {
			return
		}
		if opts.DisableEdge {
			continue
		}
		if edge.Unique {
			b.fn(
				"Get"+text.ProtoPascal(edge.Name),
				list("data", "err"),
				[]jen.Code{
					jen.Id("ctx"),
					protoID(edge.Type, jen.Id("request").Dot("GetId").Call()),
				},
				[]jen.Code{
					jen.Id("Data").Op(":").Qual(b.repositoryPackage, fmt.Sprintf("%sToProto", edge.Type.Name)).Call(jen.Id("data")).Op(","),
				},
			)
		} else {
			b.fn(
				"List"+text.ProtoPascal(edge.Name),
				list("data", "paginator", "err"),
				[]jen.Code{
					jen.Id("ctx"),
					protoID(edge.Type, jen.Id("request").Dot("GetId").Call()),
					jen.Id("request").Dot("GetOptions").Call(),
					jen.Id("request").Dot("GetPaginator").Call(),
				},
				b.listResponse(edge.Type),
			)
		}
	}
}
