package entservice

import (
	"bytes"
	"os"
	"path"
	"strings"

	"entgo.io/ent/entc/gen"
	"entgo.io/ent/schema/field"
	"github.com/dave/jennifer/jen"
)

func chain(names ...string) *jen.Statement {
	if len(names) == 0 {
		return nil
	}
	st := jen.Id(names[0])
	for _, name := range names[1:] {
		st = st.Dot(name)
	}
	return st
}

func list(names ...string) *jen.Statement {
	var st []jen.Code
	for _, name := range names {
		st = append(st, jen.Id(name))
	}
	return jen.List(st...)
}

// a,b,c = ...
func assign(names ...string) *jen.Statement {
	return list(names...).Op("=")
}

// a,b,c := ...
func define(names ...string) *jen.Statement {
	return list(names...).Op(":=")
}

// build args in separated lines
func calls(args ...*jen.Statement) *jen.Statement {
	st := jen.Op("(").Id("\n")
	for _, arg := range args {
		st = st.Add(arg.Op(",").Id("\n"))
	}
	return st.Op(")")
}

func ifErr() *jen.Statement {
	return jen.If(jen.Id("err").Op("!=").Id("nil")).Block(
		jen.Return(jen.Id("nil"), jen.Id("err")),
	)
}

func ctxType() *jen.Statement {
	return jen.Qual(pkgContext, "Context")
}

func ctxVar() *jen.Statement {
	return jen.Id("ctx").Add(ctxType())
}

// convert wrapped type to original type
// var s example.CustomString
// val := string(s)
func unwrapProto(f *gen.Field, v *jen.Statement) *jen.Statement {
	if f.Type.RType == nil || f.Type.RType.PkgPath == "" {
		return protoType(f.Type.Type, v)
	}
	return jen.Id(f.Type.RType.Kind.String()).Call(v)
}

// convert original type to wrapped type
// var s string
// val := example.CustomString(s)
func wrap(f *gen.Field, v *jen.Statement) *jen.Statement {
	if f.Type.RType == nil || f.Type.RType.PkgPath == "" {
		return entType(f.Type.Type, v)
	}
	return jen.Qual(f.Type.RType.PkgPath, f.Type.RType.Name).Call(v)
}

func entType(t field.Type, v *jen.Statement) *jen.Statement {
	switch t {
	case field.TypeInt8:
		return jen.Int8().Call(v)
	case field.TypeInt16:
		return jen.Int16().Call(v)
	case field.TypeInt32:
		return v
	case field.TypeInt:
		return jen.Int().Call(v)
	case field.TypeInt64:
		return v
	case field.TypeUint8:
		return jen.Uint8().Call(v)
	case field.TypeUint16:
		return jen.Uint16().Call(v)
	case field.TypeUint32:
		return v
	case field.TypeUint:
		return jen.Uint().Call(v)
	case field.TypeUint64:
		return v
	case field.TypeString:
		return v
	case field.TypeUUID:
		return v
	default:
		//panic(fmt.Errorf("unsupported ent id type: %s", n.ID.Type.Type))
		return v
	}
}

func protoType(t field.Type, v *jen.Statement) *jen.Statement {
	switch t {
	case field.TypeInt8, field.TypeInt16, field.TypeInt32:
		return jen.Int32().Call(v)
	case field.TypeInt, field.TypeInt64:
		return jen.Int64().Call(v)
	case field.TypeUint8, field.TypeUint32:
		return jen.Uint32().Call(v)
	case field.TypeUint, field.TypeUint64:
		return jen.Uint64().Call(v)
	case field.TypeString:
		return v
	case field.TypeUUID:
		return v.Dot("String").Call()
	default:
		return v
	}
}

// insert 'name' behind the first word in 'method'
// eg: messageName("SetStatus", "User") => "SetUserStatus"
func messageName(method, name string) string {
	n := nextCapital(method, 2)
	if n > 0 {
		return method[:n] + name + method[n:]
	}
	return method + name
}

func nextCapital(s string, n int) int {
	if n < 1 {
		n = 1
	}
	for i, c := range s {
		if c >= 'A' && c <= 'Z' {
			n--
			if n == 0 {
				return i
			}
		}
	}
	return -1
}

// Check if the old file has generated file header and auto overwrite it.
// The data will be written into the file named 'filename' only if the old file content has a generated file header or 'overwrite' is true.
func autoOverwriteFile(filename string, data []byte, overwrite bool) (bool, error) {
	old, err := os.ReadFile(filename)
	if os.IsNotExist(err) {
		_ = os.MkdirAll(path.Dir(filename), 0744)
		return true, os.WriteFile(filename, data, 0644)
	}
	if err != nil {
		return false, err
	}
	isGenerated := isGeneratedFile(old)
	if !isGenerated && !overwrite {
		return false, nil
	}

	if isGenerated && !isGeneratedFile(data) {
		data = append([]byte("// Code generated by coconutc. DO NOT EDIT.\n"), data...)
	}
	err = os.WriteFile(filename, data, 0644)
	if err != nil {
		return false, err
	}
	return true, nil
}

func isGeneratedFile(data []byte) bool {
	firstLine := string(bytes.SplitN(data, []byte("\n"), 2)[0])
	autoGenerated := strings.Contains(firstLine, "Code generated by") && strings.Contains(firstLine, "DO NOT EDIT")
	return autoGenerated
}
