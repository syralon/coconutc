package entservice

import (
	"bytes"
	"fmt"
	"math/rand"
	"os"
	"path"
	"strconv"
	"strings"

	"entgo.io/ent/entc/gen"
	"entgo.io/ent/schema/field"
	"github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"
	"github.com/syralon/coconutc/internal/tools/text"
	"github.com/syralon/coconutc/pkg/annotation/entproto"
)

func chain(names ...string) *jen.Statement {
	if len(names) == 0 {
		return nil
	}
	st := jen.Id(names[0])
	for _, name := range names[1:] {
		st = st.Dot(name)
	}
	return st
}

func list(names ...string) *jen.Statement {
	var st []jen.Code
	for _, name := range names {
		st = append(st, jen.Id(name))
	}
	return jen.List(st...)
}

// a,b,c = ...
func assign(names ...string) *jen.Statement {
	return list(names...).Op("=")
}

// a,b,c := ...
func define(names ...string) *jen.Statement {
	return list(names...).Op(":=")
}

// build args in separated lines
func calls(args ...*jen.Statement) *jen.Statement {
	st := jen.Op("(").Id("\n")
	for _, arg := range args {
		st = st.Add(arg.Op(",").Id("\n"))
	}
	return st.Op(")")
}

func ifErr() *jen.Statement {
	return jen.If(jen.Id("err").Op("!=").Id("nil")).Block(
		jen.Return(jen.Id("nil"), jen.Id("err")),
	)
}

func ctxType() *jen.Statement {
	return jen.Qual(pkgContext, "Context")
}

func ctxVar() *jen.Statement {
	return jen.Id("ctx").Add(ctxType())
}

// convert wrapped type to original type
// var s example.CustomString
// val := string(s)
func unwrapProto(f *gen.Field, v *jen.Statement) *jen.Statement {
	if f.Type.RType == nil || f.Type.RType.PkgPath == "" {
		return protoType(f.Type.Type, v)
	}
	return jen.Id(f.Type.RType.Kind.String()).Call(v)
}

// convert original type to wrapped type
// var s string
// val := example.CustomString(s)
func wrap(f *gen.Field, v *jen.Statement, opt *entproto.FieldOptions) *jen.Statement {
	if f.Type.RType == nil || f.Type.RType.PkgPath == "" {
		return entType(f.Type.Type, v, opt)
	}
	return jen.Qual(f.Type.RType.PkgPath, f.Type.RType.Name).Call(v)
}

func entType(t field.Type, v *jen.Statement, opt *entproto.FieldOptions) *jen.Statement {
	if opt != nil && opt.ProtoEnum {
		return jen.Id(t.String()).Call(v)
	}
	switch t {
	case field.TypeInt8,
		field.TypeInt16,
		field.TypeInt,
		field.TypeUint8,
		field.TypeUint16,
		field.TypeUint:
		return jen.Id(t.String()).Call(v)
	default:
		return v
	}
}

func protoType(t field.Type, v *jen.Statement) *jen.Statement {
	switch t {
	case field.TypeInt8, field.TypeInt16, field.TypeInt32:
		return jen.Int32().Call(v)
	case field.TypeInt, field.TypeInt64:
		return jen.Int64().Call(v)
	case field.TypeUint8, field.TypeUint32:
		return jen.Uint32().Call(v)
	case field.TypeUint, field.TypeUint64:
		return jen.Uint64().Call(v)
	case field.TypeString:
		return v
	case field.TypeUUID:
		return v.Dot("String").Call()
	default:
		return v
	}
}

func fieldProtoType(t field.Type) *jen.Statement {
	switch t {
	case field.TypeInt8, field.TypeInt16, field.TypeInt32:
		return jen.Int32()
	case field.TypeInt, field.TypeInt64:
		return jen.Int64()
	case field.TypeUint8, field.TypeUint32:
		return jen.Uint32()
	case field.TypeUint, field.TypeUint64:
		return jen.Uint64()
	case field.TypeString:
		return jen.String()
	case field.TypeUUID:
		return jen.String()
	default:
		return jen.Any()
	}
}

// insert 'name' behind the first word in 'method'
// eg: messageName("SetStatus", "User") => "SetUserStatus"
func messageName(method, name string) string {
	n := nextCapital(method, 2)
	if n > 0 {
		return method[:n] + name + method[n:]
	}
	return method + name
}

func nextCapital(s string, n int) int {
	if n < 1 {
		n = 1
	}
	for i, c := range s {
		if c >= 'A' && c <= 'Z' {
			n--
			if n == 0 {
				return i
			}
		}
	}
	return -1
}

// Check if the old file has generated file header and auto overwrite it.
// The data will be written into the file named 'filename' only if the old file content has a generated file header or 'overwrite' is true.
func autoOverwriteFile(filename string, data []byte, overwrite bool) (bool, error) {
	old, err := os.ReadFile(filename)
	if os.IsNotExist(err) {
		_ = os.MkdirAll(path.Dir(filename), 0744)
		return true, os.WriteFile(filename, data, 0644)
	}
	if err != nil {
		return false, err
	}
	isGenerated := isGeneratedFile(old)
	if !isGenerated && !overwrite {
		return false, nil
	}

	if isGenerated && !isGeneratedFile(data) {
		data = append([]byte("// Code generated by coconutc. DO NOT EDIT.\n"), data...)
	}
	err = os.WriteFile(filename, data, 0644)
	if err != nil {
		return false, err
	}
	return true, nil
}

func isGeneratedFile(data []byte) bool {
	firstLine := string(bytes.SplitN(data, []byte("\n"), 2)[0])
	autoGenerated := strings.Contains(firstLine, "Code generated by") && strings.Contains(firstLine, "DO NOT EDIT")
	return autoGenerated
}

func segments(codes ...jen.Code) *jen.Statement {
	if len(codes) == 0 {
		return &jen.Statement{}
	}
	stmt := make(jen.Statement, 0, len(codes)*2-1)
	for i, code := range codes {
		if i > 0 {
			stmt = append(stmt, jen.Line())
		}
		stmt = append(stmt, code)
	}
	return &stmt
}

func RandNumber(ranges ...int) *jen.Statement {
	randNumber := func(ranges ...int) int {
		switch len(ranges) {
		case 1:
			return rand.Intn(ranges[0])
		case 2:
			return ranges[0] + rand.Intn(ranges[1]-ranges[0])
		default:
			return rand.Int()
		}
	}
	return jen.Id(strconv.Itoa(randNumber(ranges...)))
}

func RandBytes(n int) *jen.Statement {
	b := make([]jen.Code, n)
	for i := range b {
		b[i] = RandNumber(256)
	}
	return jen.Op("[]").Byte().Block(b...)
}

func RandString(prefix string, n int) *jen.Statement {
	return jen.Lit(prefix + text.RandString(n))
}

func RandEnum(protoPkg string, node *gen.Type, field *gen.Field, values map[string]int32) *jen.Statement {
	for k := range values {
		name := strcase.ToScreamingSnake(fmt.Sprintf("%s_%s", node.Name, field.Name))
		value := strcase.ToScreamingSnake(fmt.Sprintf("%s_%s_%s", name, name, k))
		return jen.Qual(protoPkg, value)
	}
	return jen.Id("0")
}
