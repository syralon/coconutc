package entservice

import (
	"bufio"
	"bytes"
	"embed"
	"errors"
	"fmt"
	"go/format"
	"io"
	"os"
	"path"
	"strings"
	"text/template"

	"github.com/iancoleman/strcase"
)

//go:embed templates
var fs embed.FS
var templates *template.Template

func init() {
	funcs := map[string]any{
		"toLower": strings.ToLower,
		"camel":   strcase.ToLowerCamel,
	}
	var err error
	templates, err = template.New("").Funcs(funcs).ParseFS(fs, "templates/*.tpl")
	if err != nil {
		panic(err)
	}
}

type RenderData struct {
	Module       string
	ProtoPath    string
	ProtoPackage string
	Services     []string

	overwrite bool
}

func (r *RenderData) ValidateTemplates() error {
	buf := new(bytes.Buffer)
	for _, tpl := range templates.Templates() {
		buf.Reset()
		if err := tpl.Execute(buf, r); err != nil {
			return fmt.Errorf("%s: %w", tpl.Name(), err)
		}
		if strings.HasSuffix(tpl.Name(), ".go.tpl") {
			if _, err := format.Source(buf.Bytes()); err != nil {
				return fmt.Errorf("%s: %w", tpl.Name(), err)
			}
		}
	}
	return nil
}

func (r *RenderData) WithOverwrite(overwrite bool) *RenderData {
	if r.overwrite == overwrite {
		return r
	}
	data := new(RenderData)
	*data = *r
	data.overwrite = overwrite
	return data
}

func (r *RenderData) Render(name string) (data []byte, err error) {
	buf := new(bytes.Buffer)
	if err = templates.ExecuteTemplate(buf, name, r); err != nil {
		return nil, err
	}
	data = buf.Bytes()
	if strings.HasSuffix(name, ".go.tpl") {
		data, err = format.Source(data)
		if err != nil {
			return nil, err
		}
	}
	return data, nil
}

func (r *RenderData) RenderFiles(files map[string]string) error {
	buf := new(bytes.Buffer)
	for filename, templateName := range files {
		buf.Reset()
		if err := r.renderFile(buf, filename, templateName); err != nil {
			return err
		}
	}
	return nil
}

func (r *RenderData) RenderAllFile(output string) error {
	buf := new(bytes.Buffer)
	for _, tpl := range templates.Templates() {
		buf.Reset()
		if err := tpl.Execute(buf, r); err != nil {
			return fmt.Errorf("%s: %w", tpl.Name(), err)
		}
		var data = buf.Bytes()
		var err error
		if strings.HasSuffix(tpl.Name(), ".go.tpl") {
			data, err = format.Source(buf.Bytes())
		}
		if err != nil {
			return fmt.Errorf("%s: %w", tpl.Name(), err)
		}
		if err = r.autoWriteFile(output, tpl.Name(), data); err != nil {
			return fmt.Errorf("%s: %w", tpl.Name(), err)
		}
	}
	return nil
}

func (r *RenderData) autoWriteFile(output, name string, b []byte) error {
	reader := bufio.NewReader(bytes.NewReader(b))
	var filename = strings.TrimSuffix(name, ".tpl")
	for {
		line, err := reader.ReadString('\n')
		if errors.Is(err, io.EOF) {
			break
		}
		if err != nil {
			return err
		}
		if len(line) == 0 {
			break
		}
		if strings.HasPrefix(line, "// @") {
			filename = strings.TrimSpace(strings.TrimPrefix(line, "// @"))
		}
	}
	filename = path.Join(output, filename)
	_ = os.MkdirAll(path.Dir(filename), 0700)
	return os.WriteFile(filename, b, 0644)
}

func (r *RenderData) renderFile(buf *bytes.Buffer, filename string, name string) error {
	if err := templates.ExecuteTemplate(buf, name, r); err != nil {
		return err
	}
	data := buf.Bytes()
	if strings.HasSuffix(name, ".go.tpl") {
		var err error
		data, err = format.Source(data)
		if err != nil {
			return err
		}
	}
	firstLine := string(bytes.SplitN(data, []byte("\n"), 2)[0])
	autoGenerated := strings.Contains(firstLine, "Code generated by") && strings.Contains(firstLine, "DO NOT EDIT")
	var exist bool
	if _, err := os.Stat(filename); err == nil {
		exist = true
	}
	if exist && !autoGenerated && !r.overwrite {
		return nil
	}
	return os.WriteFile(filename, data, 0644)
}
